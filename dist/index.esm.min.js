function t(e,n,r={}){let s={};const{instance:o=t,parseJson:a=!0}=r,c=((o.buffer||"")+e).split("\n");o.buffer=c.pop(),c.forEach(((t,e)=>{if(""===t.trim()){if(a)try{s.data=JSON.parse(s.data)}catch(t){}n?.(s,e),s={}}else{const e=t.indexOf(":"),n=t.substring(0,e),r=t.substring(e+1);if(n.trim())if("data"===n)s.data=r;else s[n]=/^\d+$/.test(r)?parseInt(r):r}}))}class e{constructor(){this.controller=new AbortController}async fetch(e,n={}){const{headers:r,signal:s=this.controller.signal,parseJson:o=!0}=n;n.headers={"Content-Type":"application/json",Accept:"text/event-stream",...r};try{const a=await fetch(e,{signal:s,...n});if(!a.ok){const d=a.headers.get("content-type"),f=n.headers.Accept;throw String(d).startsWith(f)||console.error(`Expected content-type to be ${f}, Actual: ${d}`),new Error(`HTTP ${a.status}`)}n.onOpen?.(a);const c=a.body.getReader(),i=new TextDecoder;async function l(){const{done:e,value:r}=await c.read();if(e)return n.done?.(a);t(i.decode(r),n.onMessage,{instance:this,parseJson:o}),l()}l()}catch(h){this.abort(),delete this.buffer,n.onError?.(h)}}abort(){this.controller.abort()}}async function n(...t){const n=new e;return await n.fetch(...t),n}export{t as eventsourceParser,n as fetchEventSource};
//# sourceMappingURL=index.esm.min.js.map
