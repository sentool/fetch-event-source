function t(e,n,r={}){let s={};const{instance:a=t,parseJson:o=!0}=r,c=((a.buffer||"")+e).split("\n"),i=t=>n?.(t);if(a.buffer=c.pop(),0===c.length)return i(s);c.forEach((t=>{if(""===t.trim()){if(o)try{s.data=JSON.parse(s.data)}catch(t){}i(s),s={}}else{const e=t.indexOf(":"),n=t.substring(0,e).trim(),r=t.substring(e+1).trim();if(n)if("data"===n)s.data=r;else s[n]=/^\d+$/.test(r)?parseInt(r):r}}))}class e{constructor(){this.controller=new AbortController}async fetch(e,n={}){const{headers:r,signal:s=this.controller.signal,parseJson:a=!0}=n;n.headers={"Content-Type":"application/json",Accept:"text/event-stream",...r};try{const o=await fetch(e,{signal:s,...n});if(!o.ok){const f=o.headers.get("content-type"),d=n.headers.Accept;throw String(f).startsWith(d)||console.error(`Expected content-type to be ${d}, Actual: ${f}`),new Error(`HTTP ${o.status}`)}n.onOpen?.(o);const c=o.body.getReader(),i=new TextDecoder;async function l(){const{done:e,value:r}=await c.read();if(e)return n.done?.(o);t(i.decode(r),n.onMessage,{instance:this,parseJson:a}),await l()}await l()}catch(h){this.abort(),delete this.buffer,n.onError?.(h)}}abort(){this.controller.abort()}}async function n(...t){const n=new e;return await n.fetch(...t),n}export{t as eventsourceParser,n as fetchEventSource};
//# sourceMappingURL=index.esm.min.js.map
