function t(e,n,r={}){let a={};const{instance:s=t,parseJson:o=!0}=r,c=((s.buffer||"")+e).split("\n"),i=t=>n?.(t);if(s.buffer=c.pop(),0===c.length)return i(a);c.forEach((t=>{if(""===t.trim()){if(o)try{a.data=JSON.parse(a.data)}catch(t){}i(a),a={}}else{const e=t.indexOf(":"),n=t.substring(0,e).trim(),r=t.substring(e+1).trim();if(n)if("data"===n)a.data=r;else a[n]=/^\d+$/.test(r)?parseInt(r):r}}))}class e{constructor(){this.controller=new AbortController}async fetch(e,n={}){const{headers:r,signal:a=this.controller.signal,parseJson:s=!0}=n;n.headers={"Content-Type":"application/json",Accept:"text/event-stream",...r};try{const o=await fetch(e,{signal:a,...n});if(await(n.onopen?.(o)),!o.ok){const f=o.headers.get("content-type"),d=n.headers.Accept;throw String(f).startsWith(d)||console.error(`Expected content-type to be ${d}, Actual: ${f}`),new Error(`HTTP ${o.status}`)}const c=o.body.getReader(),i=new TextDecoder;async function l(){const{done:e,value:r}=await c.read();if(e)return n.done?.(o);t(i.decode(r),n.onmessage,{instance:this,parseJson:s}),await l()}await l()}catch(h){this.abort(),delete this.buffer,n.onerror?.(h)}}abort(){this.controller.abort()}}async function n(...t){const n=new e;return await n.fetch(...t),n}export{t as eventsourceParser,n as fetchEventSource};
//# sourceMappingURL=index.esm.min.js.map
