{"version":3,"file":"index.esm.min.js","sources":["../src/parse.js","../src/fetch.js"],"sourcesContent":["/**\n * SSE 文本解析\n * @param {string} chunk - decode 后的 SSE 格式数据块\n * @param {Function} callback\n * @param {Object} instance\n */\nfunction eventsourceParser(chunk, callback, options = {}) {\n  let message = {};\n  const {\n    instance = eventsourceParser,\n    parseJson = true\n  } = options;\n  const buffer = (instance.buffer || '') + chunk;\n  const lines = buffer.split('\\n');\n  const onMessage = (message) => callback?.(message);\n\n  // SSE 规范要求每个事件使用空行即 \\n\\n 进行分割\n  // 移除最后一行，若事件完整则为空行，若事件不完整则留作下次处理\n  instance.buffer = lines.pop();\n\n  // 若数据为空则直接返回\n  if (lines.length === 0) {\n    return onMessage(message, 0);\n  }\n\n  // 解析原始数据\n  lines.forEach((item) => {\n    // 空行表示一个完整事件的结束\n    if (item.trim() === '') {\n      // 是否自动解析 JSON\n      if (parseJson) {\n        try {\n          message.data = JSON.parse(message.data);\n        } catch(e) {}\n      }\n      onMessage(message); // 返回数据\n      message = {}; // 重置事件返回的数据\n    } else {\n      const fieleLength = item.indexOf(':');\n      const field = item.substring(0, fieleLength).trim();\n      const value = item.substring(fieleLength + 1).trim();\n\n      // 处理数据\n      if (field) {\n        switch (field) {\n          case 'data':\n            message.data = value;\n            break;\n          default: // id, event, retry\n            message[field] = /^\\d+$/.test(value) ? parseInt(value) : value;\n        }\n      }\n    }\n  });\n};\n\nexport default eventsourceParser;\n","import eventsourceParser from './parse.js';\n\nclass FetchEventSource {\n  constructor() {\n    this.controller = new AbortController();\n  }\n\n  /**\n   * 发起请求\n   * @param {string} url\n   * @param {Object} options\n   */\n  async fetch( url, options = {} ) {\n    const {\n      headers,\n      signal = this.controller.signal,\n      parseJson = true\n    } = options;\n\n    // 默认 headers\n    options.headers = {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"text/event-stream\",\n      ...headers,\n    };\n\n    try {\n      const response = await fetch(url, {\n        signal,\n        ...options,\n      });\n\n      // 响应异常\n      if (!response.ok) {\n        const contentType = response.headers.get('content-type');\n        const ACCEPT = options.headers['Accept'];\n        if (!String(contentType).startsWith(ACCEPT)) {\n          console.error(`Expected content-type to be ${ACCEPT}, Actual: ${contentType}`);\n        }\n        throw new Error(`HTTP ${response.status}`);\n      }\n\n      options.onOpen?.(response);\n\n      // 读取流\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      async function readStream() {\n        const { done, value } = await reader.read();\n\n        // DONE\n        if (done) return options.done?.(response);\n\n        const chunk = decoder.decode(value); // 解码 Uint8Array\n        eventsourceParser(chunk, options.onMessage, { instance: this, parseJson }); // 解析 SSE 数据格式\n\n        await readStream();\n      }\n      await readStream();\n    } catch(error) {\n      this.abort();\n      delete this.buffer;\n      options.onError?.(error);\n    }\n  }\n\n  // 中断请求\n  abort() {\n    this.controller.abort();\n  }\n}\n\n// 创建实例\nexport async function fetchEventSource(...args) {\n  const eventSource = new FetchEventSource();\n  await eventSource.fetch(...args);\n  return eventSource;\n};\n\nexport { eventsourceParser };\n"],"names":["eventsourceParser","chunk","callback","options","message","instance","parseJson","lines","buffer","split","onMessage","pop","length","forEach","item","trim","data","JSON","parse","e","fieleLength","indexOf","field","substring","value","test","parseInt","FetchEventSource","constructor","this","controller","AbortController","fetch","url","headers","signal","Accept","response","ok","contentType","get","ACCEPT","String","startsWith","console","error","Error","status","onOpen","reader","body","getReader","decoder","TextDecoder","async","readStream","done","read","decode","abort","onError","fetchEventSource","args","eventSource"],"mappings":"AAMA,SAASA,EAAkBC,EAAOC,EAAUC,EAAU,CAAA,GACpD,IAAIC,EAAU,CAAA,EACd,MAAMC,SACJA,EAAWL,EAAiBM,UAC5BA,GAAY,GACVH,EAEEI,IADUF,EAASG,QAAU,IAAMP,GACpBQ,MAAM,MACrBC,EAAaN,GAAYF,IAAWE,GAO1C,GAHAC,EAASG,OAASD,EAAMI,MAGH,IAAjBJ,EAAMK,OACR,OAAOF,EAAUN,GAInBG,EAAMM,SAASC,IAEb,GAAoB,KAAhBA,EAAKC,OAAe,CAEtB,GAAIT,EACF,IACEF,EAAQY,KAAOC,KAAKC,MAAMd,EAAQY,KACpC,CAAE,MAAMG,GAAI,CAEdT,EAAUN,GACVA,EAAU,CAAA,CACZ,KAAO,CACL,MAAMgB,EAAcN,EAAKO,QAAQ,KAC3BC,EAAQR,EAAKS,UAAU,EAAGH,GAAaL,OACvCS,EAAQV,EAAKS,UAAUH,EAAc,GAAGL,OAG9C,GAAIO,EACF,GACO,SADCA,EAEJlB,EAAQY,KAAOQ,OAGfpB,EAAQkB,GAAS,QAAQG,KAAKD,GAASE,SAASF,GAASA,CAGjE,IAEJ,CCpDA,MAAMG,EACJC,WAAAA,GACEC,KAAKC,WAAa,IAAIC,eACxB,CAOA,WAAMC,CAAOC,EAAK9B,EAAU,IAC1B,MAAM+B,QACJA,EAAOC,OACPA,EAASN,KAAKC,WAAWK,OAAM7B,UAC/BA,GAAY,GACVH,EAGJA,EAAQ+B,QAAU,CAChB,eAAgB,mBAChBE,OAAU,uBACPF,GAGL,IACE,MAAMG,QAAiBL,MAAMC,EAAK,CAChCE,YACGhC,IAIL,IAAKkC,EAASC,GAAI,CAChB,MAAMC,EAAcF,EAASH,QAAQM,IAAI,gBACnCC,EAAStC,EAAQ+B,QAAgB,OAIvC,MAHKQ,OAAOH,GAAaI,WAAWF,IAClCG,QAAQC,MAAM,+BAA+BJ,cAAmBF,KAE5D,IAAIO,MAAM,QAAQT,EAASU,SACnC,CAEA5C,EAAQ6C,SAASX,GAGjB,MAAMY,EAASZ,EAASa,KAAKC,YACvBC,EAAU,IAAIC,YACpBC,eAAeC,IACb,MAAMC,KAAEA,EAAIhC,MAAEA,SAAgByB,EAAOQ,OAGrC,GAAID,EAAM,OAAOrD,EAAQqD,OAAOnB,GAGhCrC,EADcoD,EAAQM,OAAOlC,GACJrB,EAAQO,UAAW,CAAEL,SAAUwB,KAAMvB,oBAExDiD,GACR,OACMA,GACP,CAAC,MAAMV,GACNhB,KAAK8B,eACE9B,KAAKrB,OACZL,EAAQyD,UAAUf,EACpB,CACF,CAGAc,KAAAA,GACE9B,KAAKC,WAAW6B,OAClB,EAIKL,eAAeO,KAAoBC,GACxC,MAAMC,EAAc,IAAIpC,EAExB,aADMoC,EAAY/B,SAAS8B,GACpBC,CACT"}